package minijava.syntax;
import minijava.ast.*;
import static minijava.ast.MJ.*;
import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.function.Consumer;
import frontend.SyntaxError;
import java_cup.runtime.ComplexSymbolFactory.ComplexSymbol;
class MiniJavaParser;

// Parser code to change the way the parser reports errors (include
// line and column number of the error).
parser code {:

    private Consumer<SyntaxError> onError;
    public void onError(Consumer<SyntaxError> onError) {
        this.onError = onError;
    }

    @Override
    public void syntax_error(Symbol info) {
        List<Integer> expectedTokens = expected_token_ids();

        int line, column;
        StringBuilder message = new StringBuilder("Unexpected token ");
        if (info instanceof ComplexSymbol) {
            ComplexSymbol s = (ComplexSymbol) info;
            line = s.getLeft().getLine();
            column = s.getLeft().getColumn();

            message.append(s.getName());

            if (s.value != null) {
                message.append("(");
                message.append(s.value);
                message.append(")");
            }
        } else {
            line = cur_token.left;
            column = cur_token.right;
        }

        if (!expectedTokens.isEmpty()) {
            message.append(", expected one of the following: ");
            boolean first = true;
            for (int expected : expectedTokens){
                if (!first) {
                    message.append(", ");
                }
                message.append(symbl_name_from_id(expected));
                first = false;
            }
        }


        SyntaxError err = new SyntaxError(message.toString(), line, column);
        if (onError == null) {
            System.err.println(err);
        } else {
            onError.accept(err);
        }
    }
    @Override
    public void report_fatal_error(String message, Object info) {
        // ignore
    }

:};


/* ------------Declaration of Terminals and Non Terminals Section----------- */
terminal INVALID_TOKEN;
// Java keywords:
terminal ABSTRACT,  CONTINUE,   FOR,          NEW,         SWITCH,
         ASSERT,    DEFAULT,    IF,           PACKAGE,     SYNCHRONIZED,
         BOOLEAN,   DO,         GOTO,         PRIVATE,     THIS,
         BREAK,     DOUBLE,     IMPLEMENTS,   PROTECTED,   THROW,
         BYTE,      ELSE,       IMPORT,       PUBLIC,      THROWS,
         CASE,      ENUM,       INSTANCEOF,   RETURN,      TRANSIENT,
         CATCH,     EXTENDS,    INT,          SHORT,       TRY,
         CHAR,      FINAL,      INTERFACE,    STATIC,      VOID,
         CLASS,     FINALLY,    LONG,         STRICTFP,    VOLATILE,
         CONST,     FLOAT,      NATIVE,       SUPER,       WHILE;
// additional keywords:
terminal MAIN, STRING, LENGTH, SYSTEM, OUT, PRINTLN;
// symbols:
terminal LBRACE, RBRACE, // { }
         LBRACKET, RBRACKET, // [ ]
         LPAREN, RPAREN, // ()
         DOT, SEMI, COMMA, EQ, NEG, AND, PLUS, MINUS, TIMES, DIV, LESS, EQUALS;
// literals:
terminal TRUE, FALSE, NULL;
terminal String   NUMBER, ID;

// Non terminals used in the grammar section.
non terminal MJProgram program;
non terminal MJMainClass mainClass;
non terminal MJClassDeclList classesDeclList;
non terminal MJClassDecl classDecl;
non terminal MJBlock block;
non terminal MJType type;
non terminal MJStatement statement;
non terminal MJStatement blockStatement;
non terminal MJVarDecl vardecl;
non terminal MJUnaryOperator unaryOperator;
non terminal MJTypeClass id;
non terminal MJStmtIf stmtIf;
non terminal MJStmtWhile stmtWhile;
non terminal MJExpr expr;
non terminal MJOperator operator;
non terminal List<MJStatement> blockStatementsList;
non terminal MJExprList exprsList;
non terminal MJMemberDecl memberDecl;
non terminal List<MJMemberDecl> memberDeclList;
non terminal MJExtendsNothing extendsNothing;
non terminal MJVarDeclList varDeclList;
non terminal MJExtendsClass extendsClass;

//precedence from bottom to top.
//not really sure where we should put the dot
precedence left LESS, AND, EQUALS, EQ, DOT;
precedence left  PLUS, MINUS;
precedence left  TIMES, DIV;
//brackets have precedence over operations. Used for arrays too.
precedence left LBRACKET, RBRACKET;
/* ----------------------------Grammar Section-------------------- */
//initialization of the AST
program   ::=  mainClass:mainC classesDeclList:classesDecl
      {:
            RESULT = Program(mainC, classesDecl);
      :} ;
//Detecting main class
mainClass ::= CLASS ID:className LBRACE PUBLIC STATIC VOID MAIN LPAREN STRING LBRACKET RBRACKET ID:argsName RPAREN block:blockName RBRACE
    {:
        RESULT = MainClass(className, argsName, blockName);
    :};
block ::= LBRACE blockStatementsList:blockStatements RBRACE
    {:
        //putting blockstatements into the block.
        RESULT = MJ.Block(blockStatements);
    :};
blockStatementsList ::= blockStatement:blockStatement blockStatementsList:blockStmtList
    {:
        blockStmtList.add(blockStatement);
        RESULT = blockStmtList;
    :}
    |
    {:
        RESULT = new LinkedList<MJStatement>();
    :};
blockStatement ::= statement:s
       {:
            RESULT = s;
       :}
       | type:t ID:idName SEMI
       {:
            RESULT = VarDecl(t, idName);
       :};
statement ::= IF LPAREN expr:exprCondition RPAREN statement:stmtTrue ELSE statement:stmtFalse
      {:
          RESULT = StmtIf(exprCondition, stmtTrue, stmtFalse);
      :}
      | WHILE LPAREN expr:exprCondition RPAREN statement:stmtWhile
      {:
         RESULT = StmtWhile(exprCondition, stmtWhile);
      :}
      | RETURN expr:exprReturn SEMI
      {:
         RESULT = StmtReturn(exprReturn);
      :}
      | SYSTEM DOT OUT PRINTLN LPAREN expr:exprPrint RPAREN SEMI
      {:
        RESULT = StmtPrint(exprPrint);
      :}
      | expr:exprSemi SEMI
      {:
        RESULT = StmtExpr(exprSemi);
      :}
      | expr:exprLeft EQ expr:exprRight
      {:
        RESULT = StmtAssign(exprLeft, exprRight);
      :}
      | block:b
      {:
         RESULT = b;
      :};
type ::= INT LBRACKET RBRACKET
    {:
        RESULT = TypeIntArray();
    :}
    | INT
    {:
        RESULT = TypeInt();
    :}
    | BOOLEAN
    {:
        RESULT = TypeBool();
    :}
    | ID:idName
    {:
        RESULT = TypeClass(idName);
    :};
operator ::= AND
    {:
        RESULT = And();
    :}
    | PLUS
    {:
        RESULT = Plus();
    :}
    | MINUS
    {:
        RESULT = Minus();
    :}
    | TIMES
    {:
         RESULT = Times();
    :}
    | DIV
    {:
         RESULT = Div();
    :}
    | LESS
    {:
        RESULT = Less();
    :}
    | EQUALS
    {:
        RESULT = Equals();
    :};
//introduces - expr or ! expr
unaryOperator ::= MINUS
    {:
        RESULT = UnaryMinus();
    :}
    | NEG
    {:
        RESULT = Negate();
    :}
;
expr ::= expr:exprLeft operator:o expr:exprRight
    {:
        RESULT = ExprBinary(exprLeft, o, exprRight);
    :}
    | unaryOperator:o expr:exprNeg
    {:
        RESULT = ExprUnary(o, exprNeg);
    :}
    | expr:arrayExpr LBRACKET expr:arrayIndex RBRACKET
    {:
      RESULT = ArrayLookup(arrayExpr, arrayIndex);
    :}
    | expr:exprArrLength DOT LENGTH
    {:
      RESULT = ArrayLength(exprArrLength);
    :}
    //TODO: disambiguate following expressions:
     //HOw to solve the conflict within the two following expressions?
     //| expr:exprReceiver DOT ID:fieldName
    //{:
    //  RESULT = FieldAccess(exprReceiver, fieldName);
    //:}
     //Which one should be picked? And when?
    | expr:exprReceiver DOT ID:methodName exprsList:arguments
      {:
          RESULT = MethodCall(exprReceiver, methodName, arguments);
      :}
    | TRUE
    {:
      RESULT = BoolConst(true);
    :}
    | FALSE
    {:
      RESULT = BoolConst(false);
    :}
    | ID:varName
    {:
      RESULT = VarUse(varName);
    :}
    //apparently NUMBER is a string too?
    | NUMBER:intValue
    {:
        RESULT = Number(Integer.parseInt(intValue));
    :}
    | THIS
    {:
      RESULT = ExprThis();
    :}
    | NULL
    {:
      RESULT = ExprNull();
    :}
    | NEW INT LBRACKET expr:arraySize RBRACKET
    {:
      RESULT = NewIntArray(arraySize);
    :}
    | NEW ID:className LPAREN RPAREN
    {:
      RESULT =  NewObject(className);
    :}
    | LPAREN expr:exprCur RPAREN
    {:
        RESULT = exprCur;
    :};
//TODO: found a valid argument for the list of expressions. then add it to the list
exprsList ::=
;

classDecl::= CLASS ID:className LBRACE extendsNothing:extNothing memberDeclList:membDeclList RBRACE
	{:

        //TODO: how to get the parameters that memberDecl got and pass them to the constructor?
        //Are we sure this is the right way of doing it to accept varDeclarations and method declarations
       // ClassDecl(className, extNothing, ) //missing: varDeclaration, MethodDeclaration
       
	:}
	//TODO: Class extending another class.
	;

//detecting extra classes and adding them to the list of existing classes
classesDeclList ::= classDecl:classD  classesDeclList:classesList
  {:
        //initialize it
        MJ.ClassDeclList(classesList);
        //fill it with the found class
        classesList.add(classD);
        //and finally return the list with the newly added class
        RESULT = classesList;
  :}
  //empty list of classes. return what has been found so far.
  |{:
        RESULT = MJ.ClassDeclList();
  :}
  ;

classDecl::= CLASS ID:className LBRACE extendsNothing:extNothing memberDeclList:membDeclList RBRACE
	{:

        //TODO: how to get the parameters that memberDecl got and pass them to the constructor?
        //Are we sure this is the right way of doing it to accept varDeclarations and method declarations
       // ClassDecl(className, extNothing, ) //missing: varDeclaration, MethodDeclaration
	:}
	//TODO: Class extending another class.
	;

extendsNothing ::=
    {:
        RESULT = ExtendsNothing();

    :};

memberDeclList ::=
    //found a member inside it, followed by more members
     memberDecl:membDecl memberDeclList:membDeclList
     {:

        membDeclList.add(membDecl);
        RESULT = membDeclList;
     :}
     //if empty, return an empty list
     |
     {:
        RESULT = new LinkedList<MJMemberDecl>();
     :}
;

memberDecl ::= type:t CLASS ID:typeName SEMI
    {:
        RESULT = VarDecl(t, typeName);
    :}
    | type:t ID:methodName LPAREN varDeclList:varDList RPAREN block:b
    {:
        RESULT = MethodDecl(t, methodName, varDList, b);
    :};


//TODO: varDeclList: it can also be empty!


// To be Checked
extendsNothing ::=
    {:
        RESULT = ExtendsNothing();
    :}
    | extendsClass: ClassID: ClassName
    {:
    	RESULT = ExtendsClass(ClassName)
    :};
    ;


memberDeclList ::=
    //found a member inside it, followed by more members
     memberDecl:membDecl memberDeclList:membDeclList
     {:

        membDeclList.add(membDecl);
        RESULT = membDeclList;
     :}
     //if empty, return an empty list
     |
     {:
        RESULT = new LinkedList<MJMemberDecl>();
     :}
;

memberDecl ::= type:t CLASS ID:typeName SEMI
    {:
        RESULT = VarDecl(t, typeName);
    :}
    | type:t ID:methodName LPAREN varDeclList:varDList RPAREN block:b
    {:
        RESULT = MethodDecl(t, methodName, varDList, b);
    :};


//TODO: varDeclList: it can also be empty!
//To be Checked
 varDecl::= type:t CLASS ID:typeName SEMI
 {:
    RESULT = VarDecl(t,typeName)
 :}; 
 
 