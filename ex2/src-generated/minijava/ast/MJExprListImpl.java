//generated by abstract-syntax-gen
package minijava.ast;

@SuppressWarnings({"cast", "unused"})
class MJExprListImpl extends MJExprList {
 	private MJElement parent;
	public MJElement getParent() { return parent; }
	public void setParent(MJElement parent) {
		if (parent != null && this.parent != null) {
			throw new Error("Cannot change parent of element " + this.getClass().getSimpleName() + ", as it is already used in another tree."
				+ "Use the copy method to create a new tree or remove the tree from its old parent or set the parent to null before moving the tree. ");
		}
		this.parent = parent;
	}

	public void replaceBy(MJElement other) {
		if (parent == null)
			throw new RuntimeException("Node not attached to tree.");
		for (int i=0; i<parent.size(); i++) {
			if (parent.get(i) == this) {
				parent.set(i, other);
				return;
			}
		}
	}

	protected void other_setParentToThis(MJExpr t) {
		t.setParent(this);
	}

	protected void other_clearParent(MJExpr t) {
		t.setParent(null);
	}

	@Override
	public MJElement set(int i, MJElement newElement) {
		return ((AsgList<MJExpr>) this).set(i, (MJExpr) newElement);
	}

	@Override public <T> T match(MJElement.Matcher<T> matcher) {
		return matcher.case_ExprList(this);
	}
	@Override public void match(MJElement.MatcherVoid matcher) {
		matcher.case_ExprList(this);
	}

	@Override public void accept(Visitor v) {
		v.visit(this);
	}
	@Override public void clearAttributes() {
		for (MJExpr child : this) {
			child.clearAttributes();
		}
		clearAttributesLocal();
	}
	@Override public void clearAttributesLocal() {
	}
	private frontend.SourcePosition sourcePosition;
	/** "information about the source code"*/
	public frontend.SourcePosition getSourcePosition() {
		return sourcePosition;
	}
	/** "information about the source code"*/
	public void setSourcePosition(frontend.SourcePosition sourcePosition) {
		this.sourcePosition = sourcePosition;
	}
	@Override public String toString() {
		String result =  "ExprList(";
		boolean first = true;
		for (MJExpr i : this ) {
			if (!first) { result +=", "; }
			if (result.length() > 1000) { result +="..."; break; }
			result += i;
			first = false;
		}
		result +=  ")";
		return result;
	}
}
