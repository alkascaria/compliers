%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Example: Project Report
%
% Source: http://www.howtotex.com
%
% Feel free to distribute this example, but please keep the referral
% to howtotex.com
% Date: March 2011 
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% How to use writeLaTeX: 
%
% You edit the source code here on the left, and the preview on the
% right shows you the result within a few seconds.
%
% Bookmark this page and share the URL with your co-authors. They can
% edit at the same time!
%
% You can upload figures, bibliographies, custom classes and
% styles using the files menu.
%
% If you're new to LaTeX, the wikibook is a great place to start:
% http://en.wikibooks.org/wiki/LaTeX
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Edit the title below to update the display in My Documents
%\title{Project Report}
%
%%% Preamble
\documentclass[paper=a4, fontsize=11pt]{scrartcl}
\usepackage{hyperref}

\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage{times}
\usepackage{listings}
\usepackage{filecontents}

\usepackage[english]{babel}															% English language/hyphenation
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{amsmath,amsfonts,amsthm} % Math packages
\usepackage[pdftex]{graphicx}	
\usepackage{url}
\usepackage[bottom=0.5in]{geometry}

%%% Custom sectioning
\usepackage{sectsty}
\allsectionsfont{\centering \normalfont\scshape}


%%% Custom headers/footers (fancyhdr package)
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\fancyhead{}											% No page header
\fancyfoot[L]{}											% Empty 
\fancyfoot[C]{}											% Empty
\fancyfoot[R]{\thepage}									% Pagenumbering
\renewcommand{\headrulewidth}{0pt}			% Remove header underlines
\renewcommand{\footrulewidth}{0pt}				% Remove footer underlines
\setlength{\headheight}{13.6pt}

%%% Equation and float numbering
\numberwithin{equation}{section}		% Equationnumbering: section.eq#
\numberwithin{figure}{section}			% Figurenumbering: section.fig#
\numberwithin{table}{section}				% Tablenumbering: section.tab#


%%% Maketitle metadata
\newcommand{\horrule}[1]{\rule{\linewidth}{#1}} 	% Horizontal rule

\title{
		%\vspace{-1in} 	
		\usefont{OT1}{bch}{b}{n}
		\normalfont \normalsize \textsc{Department of Computer Science, Technische Universit\"at Kaiserslautern\\
Compilers and Language Processing Tools - SS17
		} \\ [2pt]
		\horrule{0.5pt} \\[0.4cm]
		\huge A Minijava to $\mu$-LLVM Translator\\
		\horrule{2pt} \\[0.5cm]
}

\author{	
		\textbf{Exercise 4}\\
		Group 03\\
        Daniele Gadler, Gopal Praveen, Alka Scaria, Stephen Banin Payin \\[-1pt]		\normalsize
}


\date{June 14, 2017}

%%% Begin document
\begin{document}
\maketitle

\section*{Overview}
In the report, we describe the Translator from Minijava to $\mu$-LLVM. The resulting Translator is able to translate the following statements and expressions: Block, StmtIf, StmtWhile, StmtReturn, StmtPrint, StmtExpr, StmtAssign, ExprBinary, ExprUnary, BoolConst, VarUse, Number, as well as ArrayLookup, ArrayLength, ExprNull, NewIntArray. \\
The translator passes all test cases provided in the exercise' template and all test cases laid out by the group mates covering further edge cases.
We implemented our solution through the visitor pattern, breaking down the implementation into different classes for order, understandability and especially functionality purposes. Following, we describe the classes' role in the program. 


\section*{Classes' description}
\begin{itemize}
	\item \textbf{Translator}: Contains Default Visitor Pattern for the expressions and statements: MJStmtIf, MJBlock, MJStmtWhile, MJStmtPrint, MJVarDecl, MJStmtAssign. The class also has current block into which expressions are added and the Hashmap for variables' declarations.
	\item \textbf{ExprMatcherR}: Implements the visitor pattern for "MJExpr" . It matches expressions that occur on the right-hand side of an assignment operation (e.g: MJExprBinary, MJExprNull, MJExprUnary, MJArrayLookup). 
	\item \textbf{ExprMatcherL}: Implements the visitor pattern for "MJExpr". It matches expressions that occur on the left-hand side of an assignment operation (e.g: MJVarUse and MJArrayLookup). 
	\item \textbf{OperatorMatcher}: Implements the visitor pattern for "Operator" and the operation type used in a binary expressions (e.g: MJPlus, MJMinus, MJLess, MJAnd, MJDiv, MJTimes). 
	\item \textbf{StaticMethods}: Contains static methods being invoked repeatedly throughout the program for handling arrays. 
	\item \textbf{TestOutputLLVM}: Class used for testing the program and invoked by the "Main" class ("frontend"). It compares the output of the LLVM-generated program with the Minijava program and checks whether these are equal. 
\end{itemize}

\section*{Technical Description}

\subsection*{Task 1 - Translation of Statements and Expressions}

\begin{itemize}
	\item \textbf{Block}: A Block is handled as an iterable list of statements. Each statement is matched to its type in the Translator class.
	\item \textbf{StmtIf}: There are three Basic Blocks, "IF body" (condition true), "ELSE body" (condition false) and remaining code. Initially, if condition is checked and a Branch operation picks the corresponding Basicblock for execution. After evaluation of the Basicblock, execution continues for the remaining code. 
	\item \textbf{StmtWhile}: This also has three Basic Blocks, condition to be checked, while loop's body and rest of the code. The while's condition is checked: if true the condition block with a Branch statement to the while's condition is evaluated. If the condition is false, continue to remaining code.
	\item \textbf{StmtAssign} Handled by matching expressions that occur on left-hand side (ExprMatcherL) and right-hand side (ExprMatcherR) by using the visitor pattern. Invalid Expressions in the current implementation (e.g: MethodCall or ExprThis) throws an error. The class "OperatorMatcher", returns operator used in the expression. The value of matched expression on right-hand side is assigned into the left-hand side. 
	\item \textbf{StmtPrint}: In print statement, we simply check if the expression to be printed is an Integer.
	\item \textbf{VarDecl}: We allocate all newly declared variables onto the stack with space depending on their type and also store them into a HashMap.
	\item \textbf{VarUse} We distinguish between the usage on left (store) or right (load) hand side. In both cases, get the corresponding temporary variable definition (Hashmap) and the type (Type and Name Analysis). 
	\item \textbf{UnaryMinus}: Implemented the unary minus expression (ex: -b) through a binary expression, where it is multiplied by -1. 
	\item \textbf{UnaryNeg}: Implemented the unary negation expression ( ex: !b) through a XOR with a true value to invert the boolean value. 
\end{itemize}

\subsection*{Task 2 - Translation of Arrays}
\begin{itemize}

\item \textbf{NewIntArray}: Array instantiation (ex: a = new int[5]) was implemented as per the lecture slides. Let $s$ = array size (ex: 5), $b$ = size of each element (ex: ConstInt(4)). Since the array size is assigned to position 0, the amount of space ($p$) allocated for the heap is:\\
\begin{center}
 $p = (s + 1) * b$
\end{center}
More specifically, we allocate $s + 1$ blocks of size $b$ in contiguous heap space for storaging the elements and array size. Let $e_1... e_n$, where $n < s$ be a list of elements in the array at a later time: these elements will be stored according to following scheme:
\begin{center}
\begin{table}[h]
\centering
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{value}    & $s$ & $e_1$ & $e_n$ \\ \hline
\textbf{position} & 0      & 1  & n  \\ \hline
\end{tabular}
\end{table}
\end{center}
Inorder to prevent LLVM from generating random memory address on ArrayLookup for an instantiated array containing no value yet, we instantiate all blocks $1...n$ of an array to default integer value 0. 
If the array is instantiated with a negative value: the case would rise an HaltWithError exception in LLVM. 

\item \textbf{ArrayLength}: Since the length of array is stored at position 0, we simply get the array address and its first value from the heap storage.
\item \textbf{ArrayLookup}: On looking up for a value in an array, we check for these two cases.
\begin{enumerate}
	\item \textbf{Negative Index}: We ensure that a negative index was not passed and if so throw an error.
	\item \textbf{Out of bounds index}: We also ensure that a value beyond the array size is not accessed by an index $i$ that always holds: $i < s$ and throwing an error should this condition be false.
\end{enumerate}
Should these two cases are not met, then the element is retrieved by increasing the index by 1 (since the length is contained at position 0).

\end{itemize}


\begin{thebibliography}{9}% 2nd arg is the width of the widest label.
\bibitem{Joseff}
We would like to thank our study colleague Joseph for support with bitcasting arrays into the right format.
\end{thebibliography}


\end{document}